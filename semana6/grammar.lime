%class grammar
%start pgrm

%token '+' "plus operator (+)"
%token '-' "minus operator (-)"
%token '*' "multiplication operator (*)"
%token '<' "less than operator (<)"
%token '>' "greater than operator (>)"
%token '!' "not operator (!)"
%token ';' "semicolon (;)"
%token ',' "colon (,)"
%token '=' "equal (=)"
%token '.' "point (.)"
%token '{' "key left ({)"
%token '}' "key right (})"

%nonassoc '<' '>'
%left '+' '-'
%left '*'
%right T_INC

pgrm = stmts
.

stmts = /* vacÃ­o */ {
    $$ = [];
}
| stmts stmt {
    $stmts = $1;
    $stmts[] = $2;
    $$ = $stmts;
}
.

stmt = print '(' exp ')' ';' {
    $$ = new PrintStatement($3, $1['location']);
}
| var id '=' exp ';' {
    $$ = new VarDclStatement($2['value'], $4, $1['location']);
}
| id '=' exp ';' {
    $$ = new VarAssignStatement($1['value'], $3, $1['location']);
}
| if '(' exp ')' block {
    $$ = new IfStatement($3, $5, null, $1['location']);
}
| if '(' exp ')' block else block {
    $$ = new IfStatement($3, $5, $7, $1['location']);
}
| while '(' exp ')' block {
    $$ = new WhileStatement($3, $5, $1['location']);
}
| func id '(' params ')' block {
    $$ = new FunctionDclStatement($2['value'], $4, $6, $1['location']);
}
| continue ';' {
    $$ = new FlowStatement(1, null, $1['location']);
}
| break ';' {
    $$ = new FlowStatement(2, null, $1['location']);
}
| retStatement ';' {
    $$ = $1;
}
| postfix '(' args ')' ';' {
    $$ = new CallStatement($1, $3, $1->location);
}
| block {
    $$ = $1;
}
.

retStatement = return {
    $$ = new FlowStatement(3, null, $1['location']);
}
| return exp {
    $$ = new FlowStatement(3, $2, $1['location']);
}
.

block = '{' stmts '}' {
    $$ = new BlockStatement($2, $1['location']);
}
.

exp = postfix {
    $$ = $1;
}
| exp '<' exp {
    $$ = new BinaryExpression($1, '<', $3, $1->location);
}
| exp '>' exp {
    $$ = new BinaryExpression($1, '>', $3, $1->location);
}
| exp '+' exp {
    $$ = new BinaryExpression($1, '+', $3, $1->location);
}
| exp '-' exp {
    $$ = new BinaryExpression($1, '-', $3, $1->location);
}
| exp '*' exp {
    $$ = new BinaryExpression($1, '*', $3, $1->location);
}
| exp '=' '=' exp {
    $$ = new BinaryExpression($1, '==', $4, $1->location);
}
| '+' exp %prec T_INC {
    $$ = new UnaryExpression('+', $2, $2->location);
}
| '-' exp %prec T_INC {
    $$ = new UnaryExpression('-', $2, $2->location);
}
| '!' exp %prec T_INC {
    $$ = new UnaryExpression('!', $2, $2->location);
}
| '(' exp ')' {
    $$ = new AgroupedExpression($2, $2->location);
}
| array_exp {
    $$ = $1;
}
.

postfix = primitive {
    $$ = $1;
}
| postfix '(' args ')' {
    $$ = new CallStatement($1, $3, $1->location);
}
| postfix '[' exp ']' {
    $$ = new ArrayAccessExp($1, $3, $1->location);
}
.

primitive = num {
    $$ = new NumberExpression($1['value'], $1['location']);
}
| id {
    $$ = new RefVarStatement($1['value'], $1['location']);
}
| string {
    $$ = new StringExpression($1['value'], $1['location']);
}
| boolean {
    $$ = $1;
}
.

boolean = true {
    $$ = new BooleanExpression($1['value'], $1['location']);
}
| false {
    $$ = new BooleanExpression($1['value'], $1['location']);
}
.

params = /* no params */ {
    $$ = array();
}
| param_list {
    $$ = $1;
}
.

array_exp = '{' args '}' {
    $$ = new ArrayInitDcl($2, $1['location']);
}
| new var dimensions {
    $$ = new ArrayNewDcl($3, $1['location']);
}
.

dimensions = '[' exp ']' {
    $$ = array($2);
}
| dimensions '[' exp ']' {
    $1[] = $3;
    $$ = $1;
}
.

param_list = id {
    $$ = array($1['value']);
}
| param_list ',' id {
    $1[] = $3['value'];
    $$ = $1;
}
.

args = /* no args */ {
    $$ = array();
}
| arg_list {
    $$ = $1;
}
.

arg_list = exp {
    $$ = array($1);
}
| arg_list ',' exp {
    $1[] = $3;
    $$ = $1;
}
.