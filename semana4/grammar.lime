%class grammar
%start pgrm

%token '+' "plus operator (+)"
%token '-' "minus operator (-)"
%token '*' "multiplication operator (*)"
%token '<' "less than operator (<)"
%token '>' "greater than operator (>)"
%token '!' "not operator (!)"
%token ';' "semicolon (;)"
%token '=' "equal (=)"
%token '{' "key left ({)"
%token '}' "key right (})"

%nonassoc '<' '>'
%left '+' '-'
%left '*'
%right T_INC

pgrm = stmts
.

stmts = /* vac√≠o */ {
    $$ = [];
}
| stmts stmt {
    $stmts = $1;
    $stmts[] = $2;
    $$ = $stmts;
}
.

stmt = print '(' exp ')' ';' {
    $$ = new PrintStatement($3, $1['location']);
}
| var id '=' exp ';' {
    $$ = new VarDclStatement($2['value'], $4, $1['location']);
}
| id '=' exp ';' {
    $$ = new VarAssignStatement($1['value'], $3, $1['location']);
}
| if '(' exp ')' block {
    $$ = new IfStatement($3, $5, null, $1['location']);
}
| if '(' exp ')' block else block {
    $$ = new IfStatement($3, $5, $7, $1['location']);
}
| while '(' exp ')' block {
    $$ = new WhileStatement($3, $5, $1['location']);
}
| continue ';' {
    $$ = new FlowStatement(1, null, $1['location']);
}
| break ';' {
    $$ = new FlowStatement(2, null, $1['location']);
}
| block {
    $$ = $1;
}
.

block = '{' stmts '}' {
    $$ = new BlockStatement($2, $1['location']);
}
.

exp = primitive {
    $$ = $1;
}
| exp '<' exp {
    $$ = new BinaryExpression($1, '<', $3, $1->location);
}
| exp '>' exp {
    $$ = new BinaryExpression($1, '>', $3, $1->location);
}
| exp '+' exp {
    $$ = new BinaryExpression($1, '+', $3, $1->location);
}
| exp '-' exp {
    $$ = new BinaryExpression($1, '-', $3, $1->location);
}
| exp '*' exp {
    $$ = new BinaryExpression($1, '*', $3, $1->location);
}
| exp '=' '=' exp {
    $$ = new BinaryExpression($1, '==', $4, $1->location);
}
| '+' exp %prec T_INC {
    $$ = new UnaryExpression('+', $2, $2->location);
}
| '-' exp %prec T_INC {
    $$ = new UnaryExpression('-', $2, $2->location);
}
| '!' exp %prec T_INC {
    $$ = new UnaryExpression('!', $2, $2->location);
}
| '(' exp ')' {
    $$ = new AgroupedExpression($2, $2->location);
}
.

primitive = num {
    $$ = new NumberExpression($1['value'], $1['location']);
}
| id {
    $$ = new RefVarStatement($1['value'], $1['location']);
}
| boolean {
    $$ = $1;
}
.

boolean = true {
    $$ = new BooleanExpression($1['value'], $1['location']);
}
| false {
    $$ = new BooleanExpression($1['value'], $1['location']);
}
.
